# 매우 어려워했던 문제, why?
#   => 처음엔 생성자 수열을 만들어내는 함수 d를 정의하려고 하지 않고 애초에 셀프 넘버만 반환하는 함수를 정의하려다 보니
#      로직이 많이 꼬이고 코드가 길어짐. 또 출력값 또한 2로만 나와 접근 방식의 잘못됨을 느끼고 설명을 찾았다.
# 도움을 받은 접근법 포인트:
#   1. list 대신 set()을 사용
#       => 차집합이 가능한 set의 특성을 활용해서 d(n) 수열에 해당하는, 생성자가 있는 숫자들을 따로 모아 범위에서 빼준다
#   2. 2자릿수인지 3자릿수인지 상관 없다! for 문을 반복 사용하자
#       => 난 처음에 한 자릿수, 두 자릿수, 세 자릿수 수들을 구분하여 인덱싱으로 더해 in rnage() 방식으로 접근했는데
#          방식은 맞았으나 자릿수에 따라 나누지 않아도 된다
# 도움 받은 사이트: https://wook-2124.tistory.com/252

# 범위 내에 생성자가 있는 숫자들을 담은 set을 반환하는 함수 d를 정의한다
def d(maximum_number):
    # 생성자가 있는 숫자들을 담을 공백 set을 생성해준다
    not_self_numbers = set()

    # 범위 내에 있는 숫자를 1부터 하나씩 꺼내준다
    for number in range(1, maximum_number + 1):

        # 각 수를 문자열로 치환해주고 각 자릿수를 꺼내준다
        # 이렇게 하면 처음 생성자 숫자를 제외하고 추가된다
        # 처음에 여기서 for i in len(str(number))하고 number[i]식의 인덱싱 방법으로 접근하려다 보니 훨씬 비효율적이고 1/10/100 범위를
        # 구분해서 따로따로 조건문을 써야하는 수고스러움을 겪어야했다
        for char in str(number):
            # 기존의 숫자 자신에서 각 자릿수를 다시 문자열에서 정수로 치환해주어 누적합 해준다
            # 수열에 너무 매몰되어 sequence를 코드에 구현해야된다는 함정에 빠져 꼬였었다
            # 첫 수는 필요가 없으므로 number의 값을 덮어씌우는 방법이 정확하다
            # e.g. number = 850일 때, number = 850 + 8 + 5 + 0
            number += int(char)

        # 생성자가 있는 숫자 number는 셀프 넘버가 아님으로, set에 추가해준다
        # set은 .add() 함수를 사용하여 원소를 추가해준다
        not_self_numbers.add(number)

    # 해당 범위 내에 모든 숫자를 돌면서 생성자가 있는 숫자들을 추가해줬으면 차집합을 구해 셀프 넘버만 담은 set을 구한다
    # .add() 함수는 항상 마지막에 값을 추가하는 것이 아니기 때문에 문제에서 오름차순 출력을 요구하는 대로 정렬해준다
    self_numbers = sorted(set(range(1, number + 1)) - not_self_numbers)

    return self_numbers

for i in d(10000):
    print(i)