# 8단계 기본수학1 벌집
# 벌집이 형성되는 규칙에 따라 벌집의 위치를 구하는 문제

'''
지나야 하는 방 개수
1:   1
2:   2 <= N <= 7
3:   8 <= N <= 17
4:   20 <= N <= 37
5:   38 <= N <= 61
.
.
n:   range_start <= N <= range_end

규칙 찾기!

여기서 1일 때를 제외하면, 
2 .... 8 .... 20 .... 38 .... 62 ............ N ......
  (6)    (12)    (18)    (24)
(6 * 1) (6 * 2) (6 * 3) (6 * 4)   (6 * (n - 1)) (6 * n)

1. 증감치가 6의 배수이다
2. 지나야 하는 방의 개수 n에 대해 1부터 누적될 증감치 6 * (n - 1)의 n이 같다

TIP: 벌집은 hexagon이다.

'''

N = int(input())

# 범위의 시작값을 초과하면 반복문이 종료되게 구성
range_end = 1
# 지나야 하는 방 개수 1 부터 시작
n = 1
# 해당 반복문은 n이 증가할 때 마다 올라가는 벌집 번호 범위를 설정해주고 있다
# range_end의 값보다 N이 작다면, n 값에 대한 벌집 번호 범위 안에 들어온 것
# 따라서 반복문을 멈추고 누적값을 출력한다
while N > range_end:
    range_end += 6 * n
    n += 1

print(n)


'''
####### 아래는 아주 비효율적인 방법으로 접근하고 코드를 짜 시간초과로
####### 실패한 코드이다

# 근거 #
만약 방을 2번 지나면,
2 + 6 * (0) = 2 이상
2 + 6 * (0 + 1) = 8 미만

만약 방을 3번 지나면, 
2 + 6 * (0 + 1) = 8 이상
2 + (6 * 1) + (6 * 2) = 2 + 6 * (0 + 1 + 2) = 20 미만 사이의 입력값일 것이다.

고로 만약 방을 n번 지나면,
2 + 6 * (0부터 n - 2의 합) 이상
2 + 6 * (0부터 n - 1의 합) 미만 사이의 입력값일 것이다.

1부터 Z까지의 합을 구하는 공식
Z * (Z + 1) / 2
을 이용한다.

# 방법 1

# else 생략. 문제에서 N 값을 1 이상으로 제한해뒀기 때문에 가능하다.
# i를 지나가야하는 방 개수 n으로 두고,
for n in range(1, 1000000000):
    if ((n -2) * (n - 1) / 2) * 6 + 2 <= N < ((n - 1) * n / 2) * 6 + 2:
        print(n)

==> 출력문은 맞음
==> 시간 초과로 백준 통과 못 함. range 범위를 줄여야겠다.

# 방법 2

위 부등호를 재정립해서 최대한 n의 최대범위를 낮춰 반복문 횟수를 줄여야한다.
여기서 N의 최댓값 1,000,000,000을 대입해서 n의 최대범위를 줄인다.

# 범위를 최대한 줄이기 위해 최대범위는 세제곱근 처리를 하고 반올림 했다.
for n in range(1, 694):
    if (((n -2) * (n - 1) / 2) * 6 + 2) ** (1 / 3) <= N ** (1 / 3) < (((n - 1) * n / 2) * 6 + 2) ** (1 / 3):
        print(n)

==> 이 또한 예시대로 입력값 13을 넣으면 3이 반환되지만 틀렸다고 뜸

'''

'''
그 외에 implications...

- 다행히 규칙을 찾아내는 머리는 있다
- 규칙을 구현할 수도 있긴 하다
- 그런데 비효율적인 접근을 많이 한다
- 원리에 대한 roll-back 접근법을 구현하는 것이 아직 많이 미숙하다
- i.e. 시야가 좁다

'''