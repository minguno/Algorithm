'''
# 주어지는 단어 S와 대조할 알파벳 소문자 list
alphabet = [
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 
    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
    ]

# 알파벳의 위치를 입력받아 출력될 list is_in 생성
is_in = [-1] * 26

# 입력값 S를 저장 할 변수 S 생성
S = input()

# is_in list에 수정할 알파벳의 인덱스 값을 하나씩 호출한다
for idx in range(len(S)):
    # alphabet list의 인덱스 값을 하나씩 호출한다
    for i in range(len(alphabet)):
           # S 문자열의 idx 위치해 있는 알파벳이 alphabet list의 특정 인덱스에 위치한 값과 같다면
            if S[idx] == alphabet[i]:
                # 두번째 출현하는 알파벳이 있다면 이미 인덱스 값으로 변경되어 디폴트 값인 -1이
                # 아닐 것이므로, 처음 출현한 인덱스 값으로 고정하기 위해 변경하는 실행문을 건너뛴다
                if is_in[i] != -1:
                    continue
                # 해당 알파벳의 값이 디폴트 -1에서 S의 idx 값으로 변경한다
                is_in[i] = idx

# 괄호를 압축 해제한다는 의미의 *로 벗겨주고 원소별 seperator를 ' ' 공백으로 설정하여 출력한다
print(*is_in, sep=' ')
'''

'''
처음 접근하는 방법으로 결과값이 예상한 대로 나왔으나 입력값의 'baekjoon'의 'o'가 두 번 이상 나와
어떻게 해야 처음 출현하는 위치의 인덱스 값으로 fix 할 지 고민이 됐다.

디폴트 값인 -1과 다르다면 이미 출현한 알파벳일 것이므로, 명령문을 실행시키지 않는 
if != -1 조건문을 넣으면 되겠다 생각했다. 추가하는 위치와 들여쓰기를 바로 맞추지 못해 -1만 출력되었다.

'''

########################################################################
'''
더 획기적이고 덜 노가다스러운 방법을 찾았다

충격적 배움 1
바로 알파벳을 일일히 쳐서 리스트를 생성할 필요 없이 아스키 코드를 사용하는 것

충격적 배움2
string.find(a, b, c) 함수를 사용하면 된다.
string 은 문자열이다
a 는 찾고 싶은 문자이다
b 는 어디서부터 찾을지 시작하는 index이고 default = 0
c 는 어디까지 찾을지 제한해주는 index이고 default = -1

find method는 '찾을 문자' 혹은 '찾을 문자열'이 존재하는지 확인하고,
=> 존재한다면 처음으로 출현한 위치의 index를 반환해주고
=> 존재하지 않는다면 -1을 반환한다 (그러니까 애초부터 이거 쓰란 얘기)
'''

# 더 짧은 방법

word = input()

# 소문자 알파벳의 아스키코드 숫자 범위이다
alphabet = list(range(97, 123))

# 인덱스 값을 일렬로 출력하기 위한 공백 문자열
final = ''

# chr()로 아스키코드를 알파벳으로 치환해주고
# .find()로 없다면 -1 값을, 
for x in alphabet:
    final += str(word.find(chr(x)))
    final += ' '

print(final)